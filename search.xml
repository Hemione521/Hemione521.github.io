<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android拖动条(SeekBar)简单源码剖析]]></title>
    <url>%2F2018%2F03%2F13%2FAndroid%E6%8B%96%E5%8A%A8%E6%9D%A1(SeekBar)%E7%AE%80%E5%8D%95%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在Android开发的过程中，大家有可能都使用过SeekBar这个控件，比如拖动视频进度条、音频进度条等。不管大家用的多还是少，由于工作原因，个人用到的还是比较少的。然后最近在看书的时候，书中为了直观的展示颜色矩阵(ColorMatrix)的变换，有一段代码是通过SeekBar拖动来实时修改图像。 demo的样式就是下图展示的这样： 然后这段代码也很简单， 实现一个OnSeekBarChangeListener接口; 给SeekBar设置setOnSeekBarChangeListener()的监听; 重写onProgressChanged(SeekBar seekBar, int progress, boolean fromUser)方法即可。事实上，我们实际开发过程中也是这样处理的。 那么看下面代码： 1234567891011121314151617181920212223242526272829303132333435float mHue, mSaturation, mLum;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.app_activity_layout_color_matrix); ... //省略初始化控件代码 ... initSeekBarProperty();&#125;/** * 初始化进度条属性 */private void initSeekBarProperty() &#123; mSeekbarHue.setProgress(MID_VALUE); mSeekbarSaturation.setProgress(MID_VALUE); mSeekbarScale.setProgress(MID_VALUE); mSeekbarHue.setOnSeekBarChangeListener(this); mSeekbarSaturation.setOnSeekBarChangeListener(this); mSeekbarScale.setOnSeekBarChangeListener(this);&#125;@Overridepublic void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; if (seekBar == mSeekbarHue) &#123; //调整色调，色调范围在-180~180之间一个周期 mHue = (progress - MID_VALUE) * 1.0f / MID_VALUE * 180; &#125; else if (seekBar == mSeekbarSaturation) &#123; //调整饱和度 mSaturation = progress * 1.0f / MID_VALUE; &#125; else if (seekBar == mSeekbarScale) &#123; //调整亮度 mLum = progress * 1.0f / MID_VALUE; &#125; mImageMatrix.setImageBitmap(handleImageMatrix(bitmap, mHue, mSaturation, mLum));&#125; 在initSeekBarProperty()方法中为Seekbar设置当前要显示的Level，并且设置进度条改变的监听。然后运行Demo,只拖动控制色调的Seekbar，发现此时图片变成了黑色。从网上搜索答案，解决方案是： 将setOnSeekBarChangeListener()监听放在setProgress()之前 那么真正的原因是什么呢？我们从源码的角度来简单剖析一下这个问题。首先说一下Seekbar的继承关系:简单源码剖析\1520946720232.png) 首先看一下监听回调的方法：void onProgressRefresh(float scale, boolean fromUser, int progress)进入SeekBar的源码，可以看到onProgressRefresh()方法源码如下： 12345678@Override void onProgressRefresh(float scale, boolean fromUser, int progress) &#123; super.onProgressRefresh(scale, fromUser, progress); if (mOnSeekBarChangeListener != null) &#123; mOnSeekBarChangeListener.onProgressChanged(this, progress, fromUser); &#125; &#125; SeekBar的onProgressRefresh()方法里面是先执行了父类的onProgressRefresh()方法，先看AbsSeekBar，在AbsSeekBar中是没有onProgressRefresh()方法的，说明SeekBar执行的是ProgresssBar中的onProgressRefresh()方法，源码如下： 12345void onProgressRefresh(float scale, boolean fromUser, int progress) &#123; if (AccessibilityManager.getInstance(mContext).isEnabled()) &#123; scheduleAccessibilityEventSender(); &#125; &#125; 看一下，哪些地方调用了这个方法，发现只有在doRefreshProgress()方法中被调用，看一下这个方法的源码如下： 123456789private synchronized void doRefreshProgress(int id, int progress, boolean fromUser, boolean callBackToApp, boolean animate) &#123; ... 省略部分源码 ... if (isPrimary &amp;&amp; callBackToApp) &#123; onProgressRefresh(scale, fromUser, progress); &#125; &#125; 可以看到在这个方法中，fromUser这个参数也是传过来的，看一下哪些地方调用了该方法。 123456789private synchronized void refreshProgress(int id, int progress, boolean fromUser, boolean animate) &#123; if (mUiThreadId == Thread.currentThread().getId()) &#123; doRefreshProgress(id, progress, fromUser, true, animate); &#125; ... 省略部分源码 ... &#125; 再查看该方法被调用的地方，可以看到有这个一个方法调用了该方法，源码如下： 123456789101112131415161718@android.view.RemotableViewMethod synchronized boolean setProgressInternal(int progress, boolean fromUser, boolean animate) &#123; if (mIndeterminate) &#123; // Not applicable. return false; &#125; progress = MathUtils.constrain(progress, 0, mMax); if (progress == mProgress) &#123; // No change from current. return false; &#125; mProgress = progress; refreshProgress(R.id.progress, mProgress, fromUser, animate); return true; &#125; 原来是在setProgressInternal()这里被调用的，看方法名字就知道，意思是内部设置进度值，我们再看看这个方法是在哪里被调用的。 12345678910111213141516171819/** * Sets the current progress to the specified value. Does not do anything * if the progress bar is in indeterminate mode. * &lt;p&gt; * This method will immediately update the visual position of the progress * indicator. To animate the visual position to the target value, use * &#123;@link #setProgress(int, boolean)&#125;&#125;. * * @param progress the new progress, between 0 and &#123;@link #getMax()&#125; * * @see #setIndeterminate(boolean) * @see #isIndeterminate() * @see #getProgress() * @see #incrementProgressBy(int) */ @android.view.RemotableViewMethod public synchronized void setProgress(int progress) &#123; setProgressInternal(progress, false, false); &#125; 看到这里，终于看到了一个熟悉的方法，这个setProgress()就是我们在初始化的时候给seekbar设置当前进度的方法，这个方法实际上就调用了setProgressInternal()方法。第二个fromUser参数就是通过这个方法一层层分发下去。然后看到这个值为false，你会不会有点想法：什么时候这个值为true呢？答案就是当我们拖动seekbar的时候。一提到拖动，你是不是想到了onTouchEvent()事件分发？我们来看一下源码，发现只有在AbsSeekBar中重写了onTouchEvent()方法，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Override public boolean onTouchEvent(MotionEvent event) &#123; if (!mIsUserSeekable || !isEnabled()) &#123; return false; &#125; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: if (isInScrollingContainer()) &#123; mTouchDownX = event.getX(); &#125; else &#123; startDrag(event); &#125; break; case MotionEvent.ACTION_MOVE: if (mIsDragging) &#123; trackTouchEvent(event); &#125; else &#123; final float x = event.getX(); if (Math.abs(x - mTouchDownX) &gt; mScaledTouchSlop) &#123; startDrag(event); &#125; &#125; break; case MotionEvent.ACTION_UP: if (mIsDragging) &#123; trackTouchEvent(event); onStopTrackingTouch(); setPressed(false); &#125; else &#123; // Touch up when we never crossed the touch slop threshold should // be interpreted as a tap-seek to that location. onStartTrackingTouch(); trackTouchEvent(event); onStopTrackingTouch(); &#125; // ProgressBar doesn't know to repaint the thumb drawable // in its inactive state when the touch stops (because the // value has not apparently changed) invalidate(); break; case MotionEvent.ACTION_CANCEL: if (mIsDragging) &#123; onStopTrackingTouch(); setPressed(false); &#125; invalidate(); // see above explanation break; &#125; return true; &#125; 这里注意两个方法，startDrag()和trackTouchEvent() 12345678910111213141516171819private void startDrag(MotionEvent event) &#123; setPressed(true); if (mThumb != null) &#123; // This may be within the padding region. invalidate(mThumb.getBounds()); &#125; onStartTrackingTouch(); trackTouchEvent(event); attemptClaimDrag(); &#125;private void trackTouchEvent(MotionEvent event) &#123; ... 省略部分源码 ... setHotspot(x, y); setProgressInternal(Math.round(progress), true, false); &#125; 我们发现在startDrag()中也调用了trackTouchEvent()方法，然后可以看到在trackTouchEvent()最后是调用了setProgressInternal()方法去设置seekbar的进度值，并且，这个方法的第二个参数传值为true。到这里我们基本上就能明白： 当我们通过setProgress()设置进度时，这个时候fromUser传值为false； 当我们拖动seekbar时，fromUser传值为true；那么回到我们最开始的问题，为什么需要先设置监听呢? 答案在SeekBar的onProgressChanged()方法中 123if (mOnSeekBarChangeListener != null) &#123; mOnSeekBarChangeListener.onProgressChanged(this, progress, fromUser); &#125; 当我们先通过setProgress()设置进度时，此时回调到onProgressChanged()方法时，由于mOnSeekBarChangeListener == null, 所以不会去执行我们重写的onProgressChange()方法,自然也就不会去改变色调、饱和度和亮度这几个的值，由于在初始化的时候，这三个值默认为0.f，然后当饱和度和亮度为0的时候，图片会变成黑色。 如果我们先设置监听，再去通过setProgress()设置进度，此时由于mOnSeekBarChangeListener ！= null就可以回调到onProgressChanged()方法中修改三个变量的值。 ​]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android完美解决ListView复用导致的Checkbox状态混乱问题]]></title>
    <url>%2F2017%2F09%2F09%2FAndroid%E8%A7%A3%E5%86%B3Checkbox%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在Android开发中，ListView、RecyclerView和GridView控件是实现列表布局的不可或缺的工具，我觉得暂且可以这么说。比如QQ好友列表等，我们不可能用循环的方式去实现，这样对应用的性能也是有很大影响的。所以，为了记录之前遇到的这个问题，也顺便给其他需要解决这个问题的童鞋看一下，写了这篇文章（大神勿喷）！ 当然，如果你的布局比较简单，你说我没必要复用，那么你看到这里可以return了…. 如果想用但是不知道怎么用的呢(基本不存在吧)，可以参考下之前刚接触Android时写的一篇博客——Android ListView的复用优化 那么言归正传，如果你搜到这篇文章，那么你遇到的问题应该是下面这样的： 我们实现CheckBox的选中效果一般有两种： 设置CheckBox的 setOnClickListener() 监听 设置CheckBox的 setOnCheckedChangeListener() 监听 下面针对这两种实现，提出两种解决方案： 1. 通过setOnClickListener()监听实现传递给适配器的数据的实体类中添加一个是否选中的自选，比如我demo中这个，除了文本信息和图片信息外，我增加一个hasChecked属性来标记该item是否被选中，实体类信息如下： 123private String description; //文字描述private int resId; //图片idprivate boolean hasChecked; //是否选中 然后我们在Listview的Adapter适配器中去实现监听效果： 123456789101112131415mCheckBox.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // checkbox控件的方法，判断控件是否选中 if(mCheckBox.isChecked())&#123; //自己在实体类中实现的方法 对属性就行赋值 标记是否选中 mData.get(position).setHasChecked(true); //计数 为了便于观察 与此问题解决无关 selectCount++; &#125;else &#123; mData.get(position).setHasChecked(true); selectCount--; &#125; &#125; &#125;); 看到这里，你估计要说，我也是这么写的啊，为什么我的不行呢？莫慌，仔细考虑一下，之所以发生混乱是因为没有对每个item的Checkbox赋初始值，导致布局控件复用的时候，还是会使用复用到的控件的值。所以，我们只需要在设置setOnClickListener() 监听之前，为item的checkbox赋一个初始值即可解决该问题。 1mCheckBox.setChecked(mData.get(position).isHasChecked()); 2. 通过setOnCheckedChangeListener()监听实现使用该方法实现和通过方法1实现有一个共同点就是都需要给item赋一个初始值，但是不一样的地方是，如果你debug代码你可以发现，滚动的时候，你不需要点击checkbox它就会自动调用onCheckChanged()方法，然后去执行里面的逻辑，问题依旧没有解决！ 这时候，我们只需要在设置初始值之前给checkbox取消setOnCheckedChangeListener()监听就可以解决这个问题！ 1234567891011121314mCheckBox.setOnCheckedChangeListener(null);mCheckBox.setChecked(mData.get(position).isHasChecked());mCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; if(isChecked)&#123; mData.get(position).setHasChecked(true); selectCount++; &#125;else &#123; mData.get(position).setHasChecked(false); selectCount--; &#125; &#125; &#125;); 然后可以看一下效果就是这样式滴： 好了，到这里两种方法就讲完了，聪明的你是不是觉得炒鸡简单呢？如果对你有用的话，可以点个喜欢哦，谢谢（手动比心） 如果你有其他的方法欢迎同我这只菜鸟交流哦！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
      </tags>
  </entry>
</search>
