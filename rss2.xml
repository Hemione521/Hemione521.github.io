<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>骑蜗牛看大海的博客</title>
    <link>wenzhao0416.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>如果梦想能实现，那么三年算什么？</description>
    <pubDate>Sun, 10 Sep 2017 09:16:11 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Android完美解决ListView复用导致的Checkbox状态混乱问题</title>
      <link>wenzhao0416.github.io/2017/09/09/Android%E8%A7%A3%E5%86%B3Checkbox%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98/</link>
      <guid>wenzhao0416.github.io/2017/09/09/Android%E8%A7%A3%E5%86%B3Checkbox%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Sat, 09 Sep 2017 11:58:10 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;在Android开发中，ListView、RecyclerView和GridView控件是实现列表布局的不可或缺的工具，我觉得暂且可以这么说。比如QQ好友列表等，我们不可能用循环的方式去实现，这样对应用的性能也是有很大影响的。所以，为了记录之前遇到
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>在Android开发中，ListView、RecyclerView和GridView控件是实现列表布局的不可或缺的工具，我觉得暂且可以这么说。比如QQ好友列表等，我们不可能用循环的方式去实现，这样对应用的性能也是有很大影响的。所以，为了记录之前遇到的这个问题，也顺便给其他需要解决这个问题的童鞋看一下，写了这篇文章（大神勿喷）！</p></blockquote><p>当然，如果你的布局比较简单，你说我没必要复用，那么你看到这里可以return了….</p><div align="center"><img src="http://upload-images.jianshu.io/upload_images/2508513-d98488e89fb876f6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="傲娇.jpg"></div><p>如果想用但是不知道怎么用的呢(基本不存在吧)，可以参考下之前刚接触Android时写的一篇博客——<a href="http://blog.csdn.net/lr809174917/article/details/50949392" target="_blank" rel="external">Android ListView的复用优化</a></p><p>那么言归正传，如果你搜到这篇文章，那么你遇到的问题应该是下面这样的：</p><div align="center"><img src="http://upload-images.jianshu.io/upload_images/2508513-83067cdb2d083135.gif?imageMogr2/auto-orient/strip" alt="error.gif"></div><p>我们实现CheckBox的选中效果一般有两种：</p><ul><li><p>设置CheckBox的 setOnClickListener() 监听</p></li><li><p>设置CheckBox的 setOnCheckedChangeListener() 监听</p><p>下面针对这两种实现，提出两种解决方案：</p><h5 id="1-通过setOnClickListener-监听实现"><a href="#1-通过setOnClickListener-监听实现" class="headerlink" title="1. 通过setOnClickListener()监听实现"></a>1. 通过setOnClickListener()监听实现</h5><p>传递给适配器的数据的实体类中添加一个是否选中的自选，比如我demo中这个，除了文本信息和图片信息外，我增加一个hasChecked属性来标记该item是否被选中，实体类信息如下：</p><pre><code class="java">private String description; //文字描述private int resId; //图片idprivate boolean hasChecked; //是否选中</code></pre><p>然后我们在Listview的Adapter适配器中去实现监听效果：</p><pre><code class="java">mCheckBox.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                // checkbox控件的方法，判断控件是否选中                if(mCheckBox.isChecked()){                    //自己在实体类中实现的方法 对属性就行赋值 标记是否选中                    mData.get(position).setHasChecked(true);                    //计数 为了便于观察 与此问题解决无关                    selectCount++;                }else {                    mData.get(position).setHasChecked(true);                    selectCount--;                }              }        });</code></pre><p>看到这里，你估计要说，我也是这么写的啊，为什么我的不行呢？莫慌，仔细考虑一下，之所以发生混乱是因为没有对每个item的Checkbox赋初始值，导致布局控件复用的时候，还是会使用复用到的控件的值。<br>所以，我们只需要在设置setOnClickListener() 监听之前，为item的checkbox赋一个初始值即可解决该问题。</p><pre><code>mCheckBox.setChecked(mData.get(position).isHasChecked());</code></pre><h5 id="2-通过setOnCheckedChangeListener-监听实现"><a href="#2-通过setOnCheckedChangeListener-监听实现" class="headerlink" title="2. 通过setOnCheckedChangeListener()监听实现"></a>2. 通过setOnCheckedChangeListener()监听实现</h5><p>使用该方法实现和通过方法1实现有一个共同点就是都需要给item赋一个初始值，但是不一样的地方是，如果你debug代码你可以发现，滚动的时候，你不需要点击checkbox它就会自动调用onCheckChanged()方法，然后去执行里面的逻辑，问题依旧没有解决！</p><div align="center"><img src="http://upload-images.jianshu.io/upload_images/2508513-c7c4cc9e8f204b17.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="那你在这里说个毛线噻.jpg"></div><p>这时候，我们只需要在设置初始值之前给checkbox取消setOnCheckedChangeListener()监听就可以解决这个问题！</p><pre><code>mCheckBox.setOnCheckedChangeListener(null);mCheckBox.setChecked(mData.get(position).isHasChecked());mCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {            @Override            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {                if(isChecked){                    mData.get(position).setHasChecked(true);                    selectCount++;                }else {                    mData.get(position).setHasChecked(false);                    selectCount--;                }              }        });</code></pre><p>然后可以看一下效果就是这样式滴：</p><div align="center"><img src="http://upload-images.jianshu.io/upload_images/2508513-15d10ce5a7a02de2.gif?imageMogr2/auto-orient/strip" alt="normal.gif"></div><p>好了，到这里两种方法就讲完了，聪明的你是不是觉得炒鸡简单呢？<br>如果对你有用的话，可以点个喜欢哦，谢谢（手动比心）</p><div align="center"><img src="http://upload-images.jianshu.io/upload_images/2508513-4ded940dd9ccf828.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ图片20170813200511.jpg"></div><p>如果你有其他的方法欢迎同我这只菜鸟交流哦！</p></li></ul>]]></content:encoded>
      
      <comments>wenzhao0416.github.io/2017/09/09/Android%E8%A7%A3%E5%86%B3Checkbox%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
